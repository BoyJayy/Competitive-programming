// author: bjcb
//m(it)^2 2025 
/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣾⡟⣯⣽⣻⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⣴⣿⢻⣿⣿⢻⣿⣷⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣴⣿⣿⣏⣿⣿⣿⡈⢻⣽⣿⣿⣾⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢀⣴⣿⣿⣿⣿⢾⣿⣿⣿⣇⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢀⣴⠿⠿⠿⢿⣿⣿⣿⣿⣿⢻⢻⣄⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠷⠄⠀⠀⠀⠀⠀⠀⠀⠀
⠉⠀⠀⠀⠀⢸⣿⣿⣿⣿⢹⣒⠢⣿⣄⠀⠀⠚⢻⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⡏⣿⣿⡟⣿⣿⡮⠈⠀⠀⠰⣿⣿⠻⣿⣿⣧⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣼⣿⣇⠉⠋⠀⠀⡀⠀⠀⠉⠉⢀⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣄⠀⠀⢀⣉⡀⠀⠀⣠⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣷⡦⣀⣀⣀⢴⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣸⠿⢿⣿⣿⠛⠉⠀⠀⠀⠀⠀⠙⠛⢿⣿⡿⠿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⠎⠀⠀⣎⣿⣿⡂⠒⠒⢢⣤⣖⣛⣉⣁⣼⣿⡇⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣼⢀⠀⠀⠇⢹⣿⡍⡉⣹⣿⣧⠀⠀⠀⠀⣾⣿⣇⢀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢿⠀⢧⣀⡇⠘⣿⡇⠀⠉⢹⣧⡀⠀⠁⠈⣿⡿⢹⠎⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⢻⢆⠀⢿⡇⠀⠀⢸⡇⠻⣆⠀⢰⣿⠃⣺⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡄⠀⢸⡄⠃⡈⣿⡀⠀⢨⢸⡦⢻⣧⣽⠿⢰⢿⠀⠀⢸⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡅⠀⠸⡛⡄⠈⠹⠁⠀⢸⠈⣧⠀⠹⣏⢠⠇⢸⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢁⠀⠀⡇⠹⣥⠀⢡⠀⢸⠀⢸⡆⠀⢹⡟⠀⢸⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⠀⠀⣿⠀⠈⠄⠀⢡⠀⠀⠀⣧⠀⠀⢻⠀⢸⠀⠀⢸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⡄⠀⣿⠀⠀⢠⠀⠀⢣⡄⠀⢽⠀⠀⢉⣧⣿⠀⠀⣼⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢇⠀⣿⠀⠀⠀⠄⠀⠀⠃⠂⢸⡇⠠⠃⢛⣿⠀⠀⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⢠⣿⠀⠀⠀⠀⠀⠀⠈⢢⡘⠃⠀⢰⠈⣿⠶⠒⠿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠿⠘⠀⠀⠀⠀⡄⠀⠀⠈⠋⠢⠄⠈⢆⢻⠀⠀⠐⢌⢻⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠈⠁⠈⢻⣦⡭⣍⠢⣽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢻⠹⣦⣷⣽⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣷⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡄⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡆⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⠀⠀⠀⠸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠁⠀⢠⡇⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⢣⠀⠀⠀⢿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠘⣼⠀⠀⠀⡄⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⢃⠀⠀⢸⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⠀⠀⠀⠘⡆⠀⠀⠰⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⠈⡆⠀⠀⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⢡⠀⠀⠀⢃⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠘⡄⠀⢸⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠈⡄⠀⠀⠀⢆⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⢹⠀⠀⢿⣿⣿⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠘⠀⠀⠀⠈⢂⠀⠀⠀⢃⠀⠀⠀⠀⠀⠀⣇⢸⠘⣿⣿⣿⣿⣇⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣤⠀⠀⠀⠀⠀⠘⡆⡆⢹⣿⣿⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠠⢱⣷⠘⣿⣿⣿⣿⡇⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⠀⠀⠀⠀⠀⠀⠈⠀⢀⢹⣿⣿⣿⣿⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⡄⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⡆⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⢀⠀⠀⢸⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠣⠀⡀⠀⡀⠀⠀⠀⠀⣀⡀⣀⣀⣀⣀⣀⣀⣀⣆⣀⣠⣈⣴⣧⣿⣿⣿⣾⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢿⠉⠉⠉⠉⠁⠉⡍⠀⠈⡇⠀⠀⠀⠀⠀⠀⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠸⡙⠶⢄⣀⠀⠀⢣⠀⠀⡇⠀⠀⠀⠀⠀⢸⠃⣿⣿⣿⣾⣿⣿⣿⣿⣿⣇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⠈⠉⢹⠀⠀⡇⠒⠂⠐⠒⠉⢸⢹⣿⣿⣿⣾⢿⣿⣿⣿⣿⣿⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⡆⠀⡇⠀⠀⠀⠀⠀⢸⢸⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⡄⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⠀⡇⠀⠃⠀⠀⠀⠀⠀⡞⠈⣿⣿⣿⣿⣽⣿⣿⣿⣿⣿⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⣷⠀⢠⠀⠀⠀⠀⠀⡇⠀⢸⣿⣿⣯⣷⣿⣿⣿⣿⣿⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⢸⠀⠀⠀⢠⢿⠀⢸⢠⠀⠀⠀⡖⡇⠀⠀⢿⣿⣿⣿⣿⣿⣿⡟⢻⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠞⠀⡖⠀⡎⣸⠀⠸⠀⠇⠀⢀⠁⢃⠀⠀⠘⣿⣿⣿⣿⣿⣿⡧⢸⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡘⠀⠀⡇⠀⡇⢸⠀⠀⡃⠀⡇⢸⠀⢸⠀⠀⠀⢹⣿⣿⣿⣿⣿⡗⠨⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡅⠀⠀⢸⠀⠀⢸⠀⠀⠀⠀⡇⠈⠀⠀⡇⠀⠀⠀⢿⣿⣿⣿⣿⡏⠀⣿⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠘⠀⠀⡇⠀⠀⢰⠀⢡⠀⠀⠀⢃⠀⠀⠀⠘⣿⣿⣿⣿⠇⠀⢿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡄⠀⡇⠀⠀⢰⠀⠈⠀⠀⠀⢸⠀⠀⠀⠀⢸⣿⣿⡟⠀⠀⢸⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⡇⠀⠀⠸⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⣿⡇⠀⠀⢸⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⢃⢠⠃⠀⠀⠀⡇⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⣿⠁⠀⠀⢸⠃
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⠀⠀⠀⢈⢰⠀⠀⠀⠀⢱⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⡏⠀⠀⠀⢸⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⢸⠀⠀⠀⠀⠘⡄⠀⠀⠀⢸⠀⠀⠀⠀⠀⡟⠀⠀⠀⠀⢸⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⡇⢀⠀⠀⢸⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⠀⢸⠀⠀⠀⠀⠀⠸⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⢸⠀⠀⠀⠀⠀⢸⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠁⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⡆⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠞⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠰⡆⠀⠀⠀⠀⠀⡇⠀⠀⢠⡃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡆⠀⠀⠀⡇⠀⠀⠀⠀⢀⠇⣀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⢳⠀⠀⠀⠀⢸⡇⢁⣀⢹⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠰⢸⠀⠀⠀⠀⢠⣷⠿⠛⢿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⢀⣤⣤⣄⡇⠀⠀⠀⢠⠏⠀⠀⠈⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡟⠉⠀⠛⡏⠀⠀⠀⣘⣀⡤⡤⠤⢄⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡄⠀⠀⠀⢣⡀⠀⠀⣿⠓⠛⠉⠉⠉⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣶⠾⠿⠿⠿⢧⡀⠀⣿⣄⢼⣰⡴⣦⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣏⠠⡐⢄⢢⡰⣆⣴⠀⠀⠉⠛⠛⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠙⠛⠛⠒⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*/
#include <bits/stdc++.h>
//#pragma GCC optimize("O3,unroll-loops")
//#pragma GCC target("avx,avx2,bmi,bmi2,popcnt,lzcnt")
//#pragma comment(linker, "/STACK:367772160")
using namespace std;
#define all(a) (a).begin(), (a).end()
#define endl "\n"
#define vec vector
#define pii pair<int, int>
#define se second
#define fi first
#define pb push_back
#define maxel(v) *max_element(v.begin(), v.end())
#define minel(v) *min_element(v.begin(), v.end())
#define yes cout << "YES\n";
//#define m1 cout << "-1\n";
#define no cout << "NO\n";
//using i128 = __int128;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
const ll mod = 1e9 + 7;
const ll mod2 = 1e9 + 9;
const ll mod3 = 998244353;
const double pi = 3.141592653589793238;
const long double EPS = 1e-9;
const int maxn = 200000 + 5;
#define DEBUG 1
#if DEBUG
#define del cout << '\n'
#define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)
template <class X, class Y>
ostream& operator<<(ostream& os, pair<X, Y> const& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}
template <class Ch, class Tr, class Container>
basic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, Container const& x) {
    int i = 0, n = (int)distance(x.begin(), x.end());
    os << "{ ";
    for (const auto& y : x) os << y << (++i < n ? ", " : "");
    return os << " }";
}
template <typename... Args>
void _debug(const char* s, Args&&... args) {
    cout << "{ ";
    size_t i = 0, cnt = 0, n = sizeof...(args);
    auto next = [&]() {
        while (s[i] && (s[i] == ' ' || s[i] == ',')) ++i;
        size_t st = i;
        while (s[i] && s[i] != ',') ++i;
        return string(s + st, i - st);
    };
    auto dummy = {(cout << next() << ": " << args << (++cnt < n ? ", " : ""), 0)...};
    (void)dummy;
    cout << " }" << '\n';
}
#else
#define del
#define debug(...)
#endif

template <typename T>
ostream& operator<< (ostream &os, const pair<T, T>& a){
    return os << a.fi << " " << a.se;
}
template <typename T>
istream& operator>> (istream& in, pair<T, T>& a){
    in >> a.fi >> a.se;
    return in;
}
template <typename T>
ostream& operator<< (ostream &os, const vector<T>& a){
    for (int x : a) os << x << " ";
    return os;

}
template <typename T>
istream& operator>> (istream& in, vector<pair<T, T>>& a){
    for (pair<int, int>& x : a) in >> x.fi >> x.se;
    return in;
}
template <typename T>
ostream& operator<< (ostream &os, const vector<pair<T, T>>& a){
    for (pair<int, int> x : a) os << x.fi << " " << x.se << endl;
    return os;

}
template <typename T>
istream& operator>> (istream& in, vector<T>& a){
    for (int& x : a) in >> x;
    return in;
}
template <typename T>
ostream& operator<< (ostream &os, const set<T>& a){
    for (int x : a) os << x << " ";
    return os;
}
template <typename T>
ostream& operator<< (ostream &os, const map<T, T>& a){
    for (pair<int, int> x : a) os << x.fi << " " << x.se << endl;
    return os;
}
template <typename T>
void printrb(vector<T>* rb, int n) {
    for (int u = 0; u < n; ++u) {
        for (const T& v : rb[u]) {
            cout << u << " -> " << v << '\n';
        }
    }
}
template <typename T>
void print2d(const vec<vec<T>> &vec2) {
    for (const auto &row : vec2) {
        for (const auto &i : row) {
            cout << i << " ";
        }
        cout << endl;
    }
}
/*
7 5

50 28


first of all we need vertex degree
after spanning tree for that degree 
i already see dp approach with O(n^3) assym but its too a lot cuz 5000^3 is like O(5e9) so no
need to get optimization
*/
const int NMAX = 5000 + 5;
const int RMAX = 2500 + 5;
//vector<int> fact(n + 1), inv(n + 1), invfact(n + 1);
ll fact[NMAX], invfact[NMAX];
ll pow2v[NMAX];
ll P[NMAX];
ll connc[NMAX];
ll dcomp[NMAX];
ll dp[NMAX][RMAX];
ll mod_pow(ll a,ll e){
	ll r = 1;
	while (e) {
		if (e & 1) r = r * a % mod3;
		a = a * a % mod3;
		e >>=1;
	}
	return r;
}
    
int main(){
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);
    int n, k; cin >> n >> k;
    int m = n - 1;
    int R = m - k;
    int smax = R + 1;
    int up = max(m, smax);
    fact[0] = 1;
    for (int i = 1; i <= up; ++i) fact[i] = fact[i - 1] * i % mod3;
    invfact[up] = mod_pow(fact[up], mod3 - 2);
    for (int i = up; i >= 1; --i) invfact[i - 1] = invfact[i] * i % mod3;

    pow2v[0] = 1;
    for (int i = 1; i <= up; ++i) pow2v[i] = (pow2v[i - 1] * 2) % mod3;

    if (smax >= 1) {
        P[1] = 1;
        for (int s = 2; s <= smax; ++s) {
            P[s] = P[s - 1] * pow2v[s - 1] % mod3;
        }

        connc[1] = 1;
        for (int s = 2; s <= smax; ++s) {
            ll total = P[s];
            ll sub = 0;
            for (int kk = 1; kk < s; ++kk) {
                ll comb = fact[s - 1] * invfact[kk - 1] % mod3 * invfact[s - kk] % mod3;
                ll add = comb * connc[kk] % mod3 * P[s - kk] % mod3;
                sub += add;
                if (sub >= mod3) sub -= mod3;
            }
            connc[s] = total - sub;
            if (connc[s] < 0) connc[s] += mod3;
        }

        dcomp[1] = (pow2v[1] - 1 + mod3) % mod3;
        for (int s = 2; s <= smax; ++s) {
            dcomp[s] = connc[s] * ((pow2v[s] - 1 + mod3) % mod3) % mod3;
        }
    }

    dp[0][0] = 1;
    for (int i = 1; i <= m; ++i) {
        int max_r = min(R, i - 1);
        for (int r = 0; r <= max_r; ++r) {
            ll val = 0;
            int max_s = smax;
            if (max_s > i) max_s = i;
            int lim = r + 1;
            if (max_s > lim) max_s = lim;
            for (int s = 1; s <= max_s; ++s) {
                ll comb = fact[i - 1] * invfact[s - 1] % mod3 * invfact[i - s] % mod3;
                ll add = comb * dcomp[s] % mod3 * dp[i - s][r - (s - 1)] % mod3;
                val += add;
                if (val >= mod3) val -= mod3;
            }
            dp[i][r] = val;
        }
    }
    ll res = 0;
    for (int r = 0; r <= R; r++) {
    	res+=dp[m][r];
    	if (res >= mod3) res -= mod3;
    }
    res = res * n % mod3;
    cout << res << endl;
}
    