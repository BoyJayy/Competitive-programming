// author: bjcb
//m(it)^2 2025 
/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣾⡟⣯⣽⣻⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣀⣴⣿⢻⣿⣿⢻⣿⣷⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⣴⣿⣿⣏⣿⣿⣿⡈⢻⣽⣿⣿⣾⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢀⣴⣿⣿⣿⣿⢾⣿⣿⣿⣇⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢀⣴⠿⠿⠿⢿⣿⣿⣿⣿⣿⢻⢻⣄⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠷⠄⠀⠀⠀⠀⠀⠀⠀⠀
⠉⠀⠀⠀⠀⢸⣿⣿⣿⣿⢹⣒⠢⣿⣄⠀⠀⠚⢻⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⡏⣿⣿⡟⣿⣿⡮⠈⠀⠀⠰⣿⣿⠻⣿⣿⣧⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣼⣿⣇⠉⠋⠀⠀⡀⠀⠀⠉⠉⢀⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣄⠀⠀⢀⣉⡀⠀⠀⣠⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣷⡦⣀⣀⣀⢴⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣸⠿⢿⣿⣿⠛⠉⠀⠀⠀⠀⠀⠙⠛⢿⣿⡿⠿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⠎⠀⠀⣎⣿⣿⡂⠒⠒⢢⣤⣖⣛⣉⣁⣼⣿⡇⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣼⢀⠀⠀⠇⢹⣿⡍⡉⣹⣿⣧⠀⠀⠀⠀⣾⣿⣇⢀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢿⠀⢧⣀⡇⠘⣿⡇⠀⠉⢹⣧⡀⠀⠁⠈⣿⡿⢹⠎⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⢻⢆⠀⢿⡇⠀⠀⢸⡇⠻⣆⠀⢰⣿⠃⣺⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡄⠀⢸⡄⠃⡈⣿⡀⠀⢨⢸⡦⢻⣧⣽⠿⢰⢿⠀⠀⢸⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡅⠀⠸⡛⡄⠈⠹⠁⠀⢸⠈⣧⠀⠹⣏⢠⠇⢸⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢁⠀⠀⡇⠹⣥⠀⢡⠀⢸⠀⢸⡆⠀⢹⡟⠀⢸⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⠀⠀⣿⠀⠈⠄⠀⢡⠀⠀⠀⣧⠀⠀⢻⠀⢸⠀⠀⢸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⡄⠀⣿⠀⠀⢠⠀⠀⢣⡄⠀⢽⠀⠀⢉⣧⣿⠀⠀⣼⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢇⠀⣿⠀⠀⠀⠄⠀⠀⠃⠂⢸⡇⠠⠃⢛⣿⠀⠀⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⢠⣿⠀⠀⠀⠀⠀⠀⠈⢢⡘⠃⠀⢰⠈⣿⠶⠒⠿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠿⠘⠀⠀⠀⠀⡄⠀⠀⠈⠋⠢⠄⠈⢆⢻⠀⠀⠐⢌⢻⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠈⠁⠈⢻⣦⡭⣍⠢⣽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢻⠹⣦⣷⣽⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣷⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡄⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡆⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⠀⠀⠀⠸⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠁⠀⢠⡇⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⢣⠀⠀⠀⢿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠘⣼⠀⠀⠀⡄⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⢃⠀⠀⢸⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⠀⠀⠀⠘⡆⠀⠀⠰⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⠈⡆⠀⠀⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡟⠀⠀⠀⠀⢡⠀⠀⠀⢃⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠘⡄⠀⢸⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠈⡄⠀⠀⠀⢆⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⢹⠀⠀⢿⣿⣿⣿⣿⡄⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠘⠀⠀⠀⠈⢂⠀⠀⠀⢃⠀⠀⠀⠀⠀⠀⣇⢸⠘⣿⣿⣿⣿⣇⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣤⠀⠀⠀⠀⠀⠘⡆⡆⢹⣿⣿⣿⣿⠀⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠠⢱⣷⠘⣿⣿⣿⣿⡇⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⠀⠀⠀⠀⠀⠀⠈⠀⢀⢹⣿⣿⣿⣿⠀⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⡄⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⡆⠀⠀
⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⢀⠀⠀⢸⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠣⠀⡀⠀⡀⠀⠀⠀⠀⣀⡀⣀⣀⣀⣀⣀⣀⣀⣆⣀⣠⣈⣴⣧⣿⣿⣿⣾⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢿⠉⠉⠉⠉⠁⠉⡍⠀⠈⡇⠀⠀⠀⠀⠀⠀⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠸⡙⠶⢄⣀⠀⠀⢣⠀⠀⡇⠀⠀⠀⠀⠀⢸⠃⣿⣿⣿⣾⣿⣿⣿⣿⣿⣇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⠈⠉⢹⠀⠀⡇⠒⠂⠐⠒⠉⢸⢹⣿⣿⣿⣾⢿⣿⣿⣿⣿⣿⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⡆⠀⡇⠀⠀⠀⠀⠀⢸⢸⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⡄⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⠀⡇⠀⠃⠀⠀⠀⠀⠀⡞⠈⣿⣿⣿⣿⣽⣿⣿⣿⣿⣿⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⣷⠀⢠⠀⠀⠀⠀⠀⡇⠀⢸⣿⣿⣯⣷⣿⣿⣿⣿⣿⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⢸⠀⠀⠀⢠⢿⠀⢸⢠⠀⠀⠀⡖⡇⠀⠀⢿⣿⣿⣿⣿⣿⣿⡟⢻⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠞⠀⡖⠀⡎⣸⠀⠸⠀⠇⠀⢀⠁⢃⠀⠀⠘⣿⣿⣿⣿⣿⣿⡧⢸⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡘⠀⠀⡇⠀⡇⢸⠀⠀⡃⠀⡇⢸⠀⢸⠀⠀⠀⢹⣿⣿⣿⣿⣿⡗⠨⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡅⠀⠀⢸⠀⠀⢸⠀⠀⠀⠀⡇⠈⠀⠀⡇⠀⠀⠀⢿⣿⣿⣿⣿⡏⠀⣿⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠘⠀⠀⡇⠀⠀⢰⠀⢡⠀⠀⠀⢃⠀⠀⠀⠘⣿⣿⣿⣿⠇⠀⢿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡄⠀⡇⠀⠀⢰⠀⠈⠀⠀⠀⢸⠀⠀⠀⠀⢸⣿⣿⡟⠀⠀⢸⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⡇⠀⠀⠸⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⣿⡇⠀⠀⢸⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⢃⢠⠃⠀⠀⠀⡇⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⣿⠁⠀⠀⢸⠃
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢢⠀⠀⠀⢈⢰⠀⠀⠀⠀⢱⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⣿⡏⠀⠀⠀⢸⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⢸⠀⠀⠀⠀⠘⡄⠀⠀⠀⢸⠀⠀⠀⠀⠀⡟⠀⠀⠀⠀⢸⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⡇⢀⠀⠀⢸⠀⠀⠀⠀⢰⠃⠀⠀⠀⠀⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⠀⢸⠀⠀⠀⠀⠀⠸⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⢸⠀⠀⠀⠀⠀⢸⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠁⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⡆⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠞⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠰⡆⠀⠀⠀⠀⠀⡇⠀⠀⢠⡃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡆⠀⠀⠀⡇⠀⠀⠀⠀⢀⠇⣀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⢳⠀⠀⠀⠀⢸⡇⢁⣀⢹⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠰⢸⠀⠀⠀⠀⢠⣷⠿⠛⢿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⢀⣤⣤⣄⡇⠀⠀⠀⢠⠏⠀⠀⠈⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡟⠉⠀⠛⡏⠀⠀⠀⣘⣀⡤⡤⠤⢄⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡄⠀⠀⠀⢣⡀⠀⠀⣿⠓⠛⠉⠉⠉⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣶⠾⠿⠿⠿⢧⡀⠀⣿⣄⢼⣰⡴⣦⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣏⠠⡐⢄⢢⡰⣆⣴⠀⠀⠉⠛⠛⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠙⠛⠛⠒⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*/
#include <bits/stdc++.h>
//#pragma GCC optimize("O3,unroll-loops")
//#pragma GCC target("avx,avx2,bmi,bmi2,popcnt,lzcnt")
//#pragma comment(linker, "/STACK:367772160")
using namespace std;
#define all(a) (a).begin(), (a).end()
#define endl "\n"
#define vec vector
#define pii pair<int, int>
#define s second
#define f first
#define pb push_back
#define maxel(v) *max_element(v.begin(), v.end())
#define minel(v) *min_element(v.begin(), v.end())
#define yes cout << "YES\n";
//#define m1 cout << "-1\n";
#define no cout << "NO\n";
//using i128 = __int128;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
const ll mod = 1e9 + 7;
const ll mod2 = 1e9 + 9;
const ll mod3 = 998244353;
const double pi = 3.141592653589793238;
const long double EPS = 1e-9;
const int MAXN = 100000 * 5;
#define DEBUG 1
#if DEBUG
#define del cout << '\n'
#define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)
template <class X, class Y>
ostream& operator<<(ostream& os, pair<X, Y> const& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}
template <class Ch, class Tr, class Container>
basic_ostream<Ch, Tr>& operator<<(basic_ostream<Ch, Tr>& os, Container const& x) {
    int i = 0, n = (int)distance(x.begin(), x.end());
    os << "{ ";
    for (const auto& y : x) os << y << (++i < n ? ", " : "");
    return os << " }";
}
template <typename... Args>
void _debug(const char* s, Args&&... args) {
    cout << "{ ";
    size_t i = 0, cnt = 0, n = sizeof...(args);
    auto next = [&]() {
        while (s[i] && (s[i] == ' ' || s[i] == ',')) ++i;
        size_t st = i;
        while (s[i] && s[i] != ',') ++i;
        return string(s + st, i - st);
    };
    auto dummy = {(cout << next() << ": " << args << (++cnt < n ? ", " : ""), 0)...};
    (void)dummy;
    cout << " }" << '\n';
}
#else
#define del
#define debug(...)
#endif

/*that one gonna be easy cuz i can use snippet of rib build so*/
struct note {
    ll k, a, b;
};
vec<int> g[MAXN];
vec<int> addv[MAXN], remv[MAXN];
int dp1[MAXN], dp2[MAXN], prefv[MAXN], suffv[MAXN], crossv[MAXN];
int main(){
    cin.tie(0);
    cout.tie(0);
    ios_base::sync_with_stdio(0);
    int t; cin >> t;
    while(t--) {
    	int n, m;
        cin >> n >> m;
        vec<note> p(n + 1);
        for (int i = 1; i <= n; ++i) {
            cin >> p[i].k >> p[i].a >> p[i].b;
        }
        vec<int> ord(n);
        for (int i = 0; i < n; ++i) ord[i] = i + 1;
        sort(all(ord), [&](int x, int y) {
            if (p[x].k == p[y].k) return p[x].a < p[y].a;
            return p[x].k < p[y].k;
        });
        vec<note> q(n + 1);
        for (int i = 1; i <= n; ++i) {
            q[i] = p[ord[i - 1]];
        }
        for (int i = 1; i <= n; ++i) g[i].clear();
        struct event {
            ll t;
            int tp;
            int id;
        };
        vec<event> ev;
        ev.reserve(2 * n);
        for (int i = 1; i <= n; ++i) {
            ev.push_back({q[i].a, 1, i});  
            ev.push_back({q[i].b, -1, i});  
        }
        sort(all(ev), [](const event &x, const event &y) {
            if (x.t != y.t) return x.t < y.t;
            return x.tp < y.tp; 
        });
        set<int> active;
        vec<pii> edges;
        edges.reserve(5 * n);
        for (const auto &e : ev) {
            int id = e.id;
            if (e.tp == -1) {
                auto it = active.find(id);
                if (it != active.end()) active.erase(it);
            } else {
                auto it = active.lower_bound(id);

                int succ = -1, succ2 = -1, pred = -1, pred2 = -1;

                if (it != active.end()) {
                    succ = *it;
                    auto it2 = it;
                    ++it2;
                    if (it2 != active.end()) succ2 = *it2;
                }

                if (it != active.begin()) {
                    auto itp = it;
                    --itp;
                    pred = *itp;
                    if (itp != active.begin()) {
                        auto itp2 = itp;
                        --itp2;
                        pred2 = *itp2;
                    }
                }

                auto add_edge = [&](int u, int v) {
                    if (u == -1 || v == -1) return;
                    if (u > v) swap(u, v);
                    edges.pb({u, v});
                    g[u].pb(v);
                };

                add_edge(pred, id);
                add_edge(id, succ);
                add_edge(pred2, id);
                add_edge(pred, succ);
                add_edge(id, succ2);

                active.insert(id);
            }
        }
        for (int i = 1; i <= n; ++i) dp1[i] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int v : g[i]) {
                if (dp1[v] < dp1[i] + 1) dp1[v] = dp1[i] + 1;
            }
        }
        int base = 0;
        for (int i = 1; i <= n; ++i) {
            if (base < dp1[i]) base = dp1[i];
        }
        for (int i = 1; i <= n; ++i) dp2[i] = 1;
        for (int i = n; i >= 1; --i) {
            for (int v : g[i]) {
                if (dp2[i] < dp2[v] + 1) dp2[i] = dp2[v] + 1;
            }
        }
        if (m == 0) {
            cout << base << endl;
            continue;
        }
        prefv[0] = 0;
        for (int i = 1; i <= n; ++i) {
            prefv[i] = prefv[i - 1];
            if (prefv[i] < dp1[i]) prefv[i] = dp1[i];
        }
        suffv[n + 1] = 0;
        for (int i = n; i >= 1; --i) {
            suffv[i] = suffv[i + 1];
            if (suffv[i] < dp2[i]) suffv[i] = dp2[i];
        }
        for (int i = 1; i <= n + 1; ++i) {
            addv[i].clear();
            remv[i].clear();
        }
        for (auto e : edges) {
            int u = e.f;
            int v = e.s;
            if (u + 1 >= v) continue;
            int w = dp1[u] + dp2[v];
            int L = u + 1;
            int R = v;
            addv[L].pb(w);
            remv[R].pb(w);
        }
        multiset<int> cur;
        for (int i = 1; i <= n; ++i) {
            for (int w : remv[i]) {
                auto it = cur.find(w);
                if (it != cur.end()) cur.erase(it);
            }
            for (int w : addv[i]) cur.insert(w);
            crossv[i] = cur.empty() ? 0 : *cur.rbegin();
        }
        int ans = base;
        for (int x = 1; x <= n; ++x) {
            int best = prefv[x - 1];
            if (best < suffv[x + 1]) best = suffv[x + 1];
            if (best < crossv[x]) best = crossv[x];
            if (ans > best) ans = best;
        }
        cout << ans << endl;
    }
}
    