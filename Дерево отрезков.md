# Деревья отрезков: теория, реализация, оптимизация и применения

Деревья отрезков — мощная структура данных, позволяющая эффективно выполнять запросы и обновления на диапазонах массива. В данной статье разберём теорию, реализацию, оптимизацию и примеры применения.

## 1. Теория по дереву отрезков

### Основная идея
Дерево отрезков — это бинарное дерево, где каждый узел отвечает за некоторый отрезок массива. Корень хранит агрегированное значение для всего массива, а листья — значения отдельных элементов. Запрос обрабатывается за `O(log N)`, разбивая массив на логарифмическое число отрезков.

### Основные операции
- **Построение (Build)**: рекурсивное построение дерева.
- **Запрос (Query)**: вычисление агрегата на заданном диапазоне.
- **Обновление (Update)**: изменение значения и обновление родительских узлов.
- **Ленивая (Lazy) обработка**: массовые обновления с отложенным перерасчётом.

## 2. План реализации

1. **Определение размера дерева** (обычно ближайшая степень двойки).
2. **Инициализация массива узлов** (включая lazy propagation при необходимости).
3. **Построение дерева** (заполнение листьев и агрегация снизу вверх).
4. **Реализация запросов и обновлений** (с учётом ленивых обновлений).

## 3. Пример кода на C++

```cpp
struct Tree {
    int sz = 1;
    vector<int> nodes;
    vector<int> otl;    // массив для ленивых обновлений
    vector<int> sizes;  // размеры отрезков для каждого узла

    Tree(vector<int>& a) {
        while (sz < a.size()) sz *= 2;
        nodes.resize(2 * sz);
        otl.resize(2 * sz, 0);
        sizes.resize(2 * sz);
        for (int i = 0; i < a.size(); i++) {
            nodes[i + sz] = a[i];
            sizes[i + sz] = 1;
        }
        for (int i = sz - 1; i >= 1; i--) {
            nodes[i] = nodes[i * 2] + nodes[i * 2 + 1];
            sizes[i] = sizes[i * 2] + sizes[i * 2 + 1];
        }
    }

    void push(int x) {
        otl[x * 2] += otl[x];
        otl[x * 2 + 1] += otl[x];
        nodes[x] += otl[x] * sizes[x];
        otl[x] = 0;
    }

    int get_val(int x) {
        return nodes[x] + otl[x] * sizes[x];
    }

    int get_sum(int now, int l, int r, int lq, int rq) {
        if (l >= lq && r <= rq) return get_val(now);
        if (l >= rq || r <= lq) return 0;
        push(now);
        int l_s = get_sum(now * 2, l, (l + r) / 2, lq, rq);
        int r_s = get_sum(now * 2 + 1, (l + r) / 2, r, lq, rq);
        return l_s + r_s;
    }

    void update(int num, int now, int l, int r, int lq, int rq) {
        if (l >= lq && r <= rq) {
            otl[now] += num;
            return;
        }
        if (r <= lq || l >= rq) return;
        push(now);
        update(num, now * 2, l, (l + r) / 2, lq, rq);
        update(num, now * 2 + 1, (l + r) / 2, r, lq, rq);
        nodes[now] = get_val(now * 2) + get_val(now * 2 + 1);
    }
};
```

## 4. Виды деревьев отрезков

- **Дерево для суммы**: хранит сумму значений на отрезке.
- **Дерево для минимума/максимума**: хранит `min` или `max` на отрезке.
- **Дерево с ленивыми обновлениями**: для массовых изменений.
- **Persistent Segment Tree**: сохраняет историю изменений.
- **Li Chao Tree**: для работы с линейными функциями.

## 5. Оптимизация

- **Ленивая обработка** (`Lazy Propagation`).
- **Итеративная реализация** (избегает рекурсии).
- **Оптимизация памяти** (уменьшает фрагментацию).
- **Учет специфики задачи** (оптимальные операции агрегации).

## 6. Применения

- **Алгоритмические соревнования** (запросы на отрезках).
- **Обработка данных в реальном времени** (игры, мониторинг).
- **Базы данных и аналитика** (агрегация статистики).
- **Графические приложения** (динамическая обработка данных).

## 7. Альтернативные реализации

- **Фенвик дерево (BIT)**: упрощённый аналог дерева отрезков.
- **Persistent Segment Tree**: поддержка версионности данных.
- **Li Chao Tree**: для задач с линейными функциями.
- **Дерево для поиска `k`-го элемента**: хранит количество элементов в узлах.

