Деревья отрезков: теория, реализация, оптимизация и применения

Деревья отрезков — мощная структура данных, позволяющая эффективно выполнять запросы и обновления на диапазонах (отрезках) массива. В статье разберём теорию, этапы реализации, основные виды деревьев отрезков, методы оптимизации, примеры применения и альтернативные реализации.

1. Теория по дереву отрезков

Основная идея

Дерево отрезков — бинарное дерево, где каждый узел отвечает за некоторый отрезок массива. Корень хранит агрегированное значение для всего массива, листья — значения отдельных элементов. Запрос (сумма, минимум, максимум) обрабатывается за O(log N).

Основные операции:

Построение (Build): Рекурсивное агрегирование значений дочерних узлов.

Запрос (Query): Вычисление агрегата на заданном диапазоне.

Обновление (Update): Изменение значений элементов с обновлением родительских узлов.

Ленивая (Lazy) обработка: Отложенные массовые обновления до момента запроса.

2. План реализации

Этапы реализации:

Определение размера дерева (обычно степень двойки).

Инициализация массивов узлов и ленивых обновлений.

Построение дерева снизу вверх.

Реализация запросов и обновлений с поддержкой ленивых обновлений.

Пример реализации на C++:

struct Tree {
    int sz = 1;
    vector<int> nodes, otl, sizes;

    Tree(vector<int>& a) {
        while (sz < a.size()) sz *= 2;
        nodes.resize(2 * sz);
        otl.resize(2 * sz, 0);
        sizes.resize(2 * sz);

        for (int i = 0; i < a.size(); i++) {
            nodes[i + sz] = a[i];
            sizes[i + sz] = 1;
        }
        for (int i = sz - 1; i >= 1; i--) {
            nodes[i] = nodes[2 * i] + nodes[2 * i + 1];
            sizes[i] = sizes[2 * i] + sizes[2 * i + 1];
        }
    }

    void push(int x) {
        otl[2 * x] += otl[x];
        otl[2 * x + 1] += otl[x];
        nodes[x] += otl[x] * sizes[x];
        otl[x] = 0;
    }

    int get_val(int x) {
        return nodes[x] + otl[x] * sizes[x];
    }

    int get_sum(int now, int l, int r, int lq, int rq) {
        if (l >= lq && r <= rq) return get_val(now);
        if (l >= rq || r <= lq) return 0;
        push(now);
        int m = (l + r) / 2;
        return get_sum(2 * now, l, m, lq, rq) + get_sum(2 * now + 1, m, r, lq, rq);
    }

    void update(int num, int now, int l, int r, int lq, int rq) {
        if (l >= lq && r <= rq) {
            otl[now] += num;
            return;
        }
        if (r <= lq || l >= rq) return;
        push(now);
        int m = (l + r) / 2;
        update(num, 2 * now, l, m, lq, rq);
        update(num, 2 * now + 1, m, r, lq, rq);
        nodes[now] = get_val(2 * now) + get_val(2 * now + 1);
    }
};

2. Основные виды деревьев отрезков

Сумма (вышеуказанный пример).

Минимум/максимум.

Дерево k-го элемента (для поиска k-го элемента).

Persistent Segment Tree (стойкие деревья, история состояний).

4. Методы оптимизации

Ленивая обработка (Lazy Propagation).

Итеративная реализация вместо рекурсивной.

Специализированные операции агрегации (для конкретных задач).

Оптимизация памяти (использование минимального числа узлов).

5. Применения деревьев отрезков

Алгоритмические соревнования (быстрые решения задач с диапазонами).

Системы реального времени (мониторинг, игровые движки).

Базы данных и аналитика (временные ряды, агрегация данных).

Графические приложения (рендеринг, игры).

6. Альтернативные реализации

Фенвик (Fenwick Tree): для сумм на префиксах.

Persistent Segment Tree: хранение истории изменений.

Li Chao Tree: запросы на оптимальное значение функции на точке.
